/**
 * Returns a `Promise` that is fulfilled when all promises generated by mapping `array` to `fn` are fulfilled,
 * or rejects if any of the promises reject. The fulfilled value is an `Array` of the fulfilled values returned from `fn` in `array` order.
 *
 * @param limit concurrency limit
 * @param array
 * @param fn Expected to return a `Promise` or value.
 */
export function asyncPool<T, U>(
  limit: number,
  array: T[],
  fn: (item: T, index: number, array: T[]) => Promise<U> | U,
): Promise<U[]> {
  if (array.length <= limit) {
    return Promise.resolve().then(() => Promise.all(array.map(fn)));
  }
  let failed = false;
  return new Promise<U[]>((resolve, reject) => {
    const results: U[] = new Array(array.length);
    let index = 0;
    let executing = 0;

    const tick = () => {
      if (!failed) {
        if (index < array.length) {
          const currentIndex = index;
          index++;
          executing++;

          Promise.resolve()
            .then(() => fn(array[currentIndex], currentIndex, array))
            .then(
              (result) => {
                results[currentIndex] = result;
                executing--;
                tick();
              },
              (error) => {
                failed = true;
                reject(error);
              },
            );
        } else if (executing === 0) {
          resolve(results);
        }
      }
    };

    for (let i = 0; i < limit; i++) {
      tick();
    }
  });
}

export default asyncPool;
